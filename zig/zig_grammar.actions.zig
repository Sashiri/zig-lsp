// AutoGenerated file

const Types = @import("zig_grammar.types.zig");
const Errors = @import("zig_grammar.errors.zig");
const Tokens = @import("zig_grammar.tokens.zig");

usingnamespace Types;
usingnamespace Errors;
usingnamespace Tokens;

pub const StackItem = struct {
    item: usize,
    state: i16,
    value: StackValue,
};

pub const StackValue = union(enum) {
    Token: Id,
    Terminal: TerminalId,
};

pub fn reduce_actions(comptime Parser: type, parser: *Parser, rule: isize, state: i16) !TerminalId {
    switch (rule) {
        1 => {
            // Symbol: Root
            var result: *Node = undefined;
            // Symbol: MaybeRootDocComment
            const arg1 = @intToPtr(?*Node.DocComment, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: MaybeContainerMembers
            const arg2 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 1].item);

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Root);
                node.doc_comments = arg1;
                node.decls = if (arg2) |p| p.* else NodeList.init(parser.allocator);
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Root };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Root;
        },
        2 => {
            // Symbol: MaybeDocComment
            var result: ?*Node.DocComment = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeDocComment } });
            return TerminalId.MaybeDocComment;
        },
        3 => {
            // Symbol: MaybeDocComment
            var result: ?*Node.DocComment = null;
            // Symbol: DocCommentLines
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.DocComment);
                node.lines = arg1.*;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeDocComment };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeDocComment;
        },
        4 => {
            // Symbol: DocCommentLines
            var result: *TokenList = undefined;
            // Symbol: DocCommentLines
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: DocComment
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg2);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .DocCommentLines };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.DocCommentLines;
        },
        5 => {
            // Symbol: DocCommentLines
            var result: *TokenList = undefined;
            // Symbol: DocComment
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithToken(TokenList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .DocCommentLines };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.DocCommentLines;
        },
        6 => {
            // Symbol: MaybeRootDocComment
            var result: ?*Node.DocComment = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeRootDocComment } });
            return TerminalId.MaybeRootDocComment;
        },
        7 => {
            // Symbol: MaybeRootDocComment
            var result: ?*Node.DocComment = null;
            // Symbol: RootDocCommentLines
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.DocComment);
                node.lines = arg1.*;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeRootDocComment };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeRootDocComment;
        },
        8 => {
            // Symbol: RootDocCommentLines
            var result: *TokenList = undefined;
            // Symbol: RootDocCommentLines
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RootDocComment
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg2);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .RootDocCommentLines };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.RootDocCommentLines;
        },
        9 => {
            // Symbol: RootDocCommentLines
            var result: *TokenList = undefined;
            // Symbol: RootDocComment
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithToken(TokenList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .RootDocCommentLines };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.RootDocCommentLines;
        },
        10 => {
            // Symbol: MaybeContainerMembers
            var result: ?*NodeList = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeContainerMembers } });
            return TerminalId.MaybeContainerMembers;
        },
        11 => {
            // Symbol: MaybeContainerMembers
            var result: ?*NodeList = null;
            // Symbol: ContainerMembers
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeContainerMembers };
            return TerminalId.MaybeContainerMembers;
        },
        12 => {
            // Symbol: ContainerMembers
            var result: *NodeList = undefined;
            // Symbol: ContainerMembers
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: ContainerMember
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg2);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerMembers };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerMembers;
        },
        13 => {
            // Symbol: ContainerMembers
            var result: *NodeList = undefined;
            // Symbol: ContainerMember
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithNode(NodeList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerMembers };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerMembers;
        },
        14 => {
            // Symbol: ContainerMember
            var result: *Node = undefined;
            // Symbol: MaybeDocComment
            const arg1 = @intToPtr(?*Node.DocComment, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: TestDecl
            const arg2 = @intToPtr(?*Node.TestDecl, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
                arg2.doc_comments = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerMember };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerMember;
        },
        15 => {
            // Symbol: ContainerMember
            var result: *Node = undefined;
            // Symbol: MaybeDocComment
            const arg1 = @intToPtr(?*Node.DocComment, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: TopLevelComptime
            const arg2 = @intToPtr(?*Node.Comptime, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
                arg2.doc_comments = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerMember };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerMember;
        },
        16 => {
            // Symbol: ContainerMember
            var result: *Node = undefined;
            // Symbol: MaybeDocComment
            const arg1 = @intToPtr(?*Node.DocComment, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybePub
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: TopLevelDecl
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg3;
                if (arg3.cast(Node.VarDecl)) |node| {
                    node.doc_comments = arg1;
                    node.visib_token = arg2;
                } else if (arg3.cast(Node.FnProto)) |node| {
                    node.doc_comments = arg1;
                    node.visib_token = arg2;
                } else {
                    const node = arg3.unsafe_cast(Node.Use);
                    node.doc_comments = arg1;
                    node.visib_token = arg2;
                }
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerMember };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerMember;
        },
        17 => {
            // Symbol: ContainerMember
            var result: *Node = undefined;
            // Symbol: MaybeDocComment
            const arg1 = @intToPtr(?*Node.DocComment, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybePub
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: ContainerField
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Comma
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg3;
                const node = arg3.unsafe_cast(Node.ContainerField);
                node.doc_comments = arg1;
                node.visib_token = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerMember };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerMember;
        },
        18 => {
            // Symbol: TestDecl
            var result: *Node.TestDecl = undefined;
            // Symbol: Keyword_test
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: StringLiteral
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Block
            const arg3 = @intToPtr(?*Node.Block, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.StringLiteral);
                name.token = arg2;
                const node = try parser.createNode(Node.TestDecl);
                node.test_token = arg1;
                node.name = &name.base;
                node.body_node = &arg3.base;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TestDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TestDecl;
        },
        19 => {
            // Symbol: TopLevelComptime
            var result: *Node.Comptime = undefined;
            // Symbol: Keyword_comptime
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BlockExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Comptime);
                node.comptime_token = arg1;
                node.expr = arg2;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelComptime };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelComptime;
        },
        20 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: FnProto
            const arg1 = @intToPtr(?*Node.FnProto, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        21 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: FnProto
            const arg1 = @intToPtr(?*Node.FnProto, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Block
            const arg2 = @intToPtr(?*Node.Block, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                arg1.body_node = &arg2.base;
                result = &arg1.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        22 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_extern
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: StringLiteral
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: FnProto
            const arg3 = @intToPtr(?*Node.FnProto, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg3.base;
                const lib_name = try parser.createNode(Node.StringLiteral);
                lib_name.token = arg2;
                arg3.extern_export_inline_token = arg1;
                arg3.lib_name = &lib_name.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        23 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_extern
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: StringLiteral
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: FnProto
            const arg3 = @intToPtr(?*Node.FnProto, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Block
            const arg4 = @intToPtr(?*Node.Block, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg3.base;
                const lib_name = try parser.createNode(Node.StringLiteral);
                lib_name.token = arg2;
                arg3.extern_export_inline_token = arg1;
                arg3.lib_name = &lib_name.base;
                arg3.body_node = &arg4.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        24 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_export
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: FnProto
            const arg2 = @intToPtr(?*Node.FnProto, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
                arg2.extern_export_inline_token = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        25 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_inline
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: FnProto
            const arg2 = @intToPtr(?*Node.FnProto, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
                arg2.extern_export_inline_token = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        26 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_export
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: FnProto
            const arg2 = @intToPtr(?*Node.FnProto, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Block
            const arg3 = @intToPtr(?*Node.Block, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
                arg2.extern_export_inline_token = arg1;
                arg2.body_node = &arg3.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        27 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_inline
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: FnProto
            const arg2 = @intToPtr(?*Node.FnProto, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Block
            const arg3 = @intToPtr(?*Node.Block, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
                arg2.extern_export_inline_token = arg1;
                arg2.body_node = &arg3.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        28 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: MaybeThreadlocal
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: VarDecl
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg2;
                const node = arg2.unsafe_cast(Node.VarDecl);
                node.thread_local_token = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        29 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_extern
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: StringLiteral
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeThreadlocal
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: VarDecl
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg4;
                const lib_name = try parser.createNode(Node.StringLiteral);
                lib_name.token = arg2;
                const node = arg4.unsafe_cast(Node.VarDecl);
                node.extern_export_token = arg1;
                node.lib_name = &lib_name.base;
                node.thread_local_token = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        30 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_export
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeThreadlocal
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: VarDecl
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg3;
                const node = arg3.unsafe_cast(Node.VarDecl);
                node.extern_export_token = arg1;
                node.thread_local_token = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        31 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_extern
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeThreadlocal
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: VarDecl
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg3;
                const node = arg3.unsafe_cast(Node.VarDecl);
                node.extern_export_token = arg1;
                node.thread_local_token = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        32 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_usingnamespace
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Use);
                node.use_token = arg1;
                node.expr = arg2;
                node.semicolon_token = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        33 => {
            // Symbol: TopLevelDecl
            var result: *Node = undefined;
            // Symbol: Keyword_use
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Use);
                node.use_token = arg1;
                node.expr = arg2;
                node.semicolon_token = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .TopLevelDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.TopLevelDecl;
        },
        34 => {
            // Symbol: MaybeThreadlocal
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeThreadlocal } });
            return TerminalId.MaybeThreadlocal;
        },
        35 => {
            // Symbol: MaybeThreadlocal
            var result: ?*Token = null;
            // Symbol: Keyword_threadlocal
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeThreadlocal };
            return TerminalId.MaybeThreadlocal;
        },
        36 => {
            // Symbol: FnProto
            var result: *Node.FnProto = undefined;
            // Symbol: MaybeFnCC
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 9].item);
            // Symbol: Keyword_fn
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item).?;
            // Symbol: MaybeIdentifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item);
            // Symbol: LParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeParamDeclList
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: RParen
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: MaybeByteAlign
            const arg7 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybeLinkSection
            const arg8 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Expr
            const arg9 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 8;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.FnProto);
                node.cc_token = arg1;
                node.fn_token = arg2;
                node.name_token = arg3;
                node.params = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.align_expr = arg7;
                node.section_expr = arg8;
                node.return_type = Node.FnProto.ReturnType{ .Explicit = arg9 };
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .FnProto };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.FnProto;
        },
        37 => {
            // Symbol: FnProto
            var result: *Node.FnProto = undefined;
            // Symbol: MaybeFnCC
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 10].item);
            // Symbol: Keyword_fn
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 9].item).?;
            // Symbol: MaybeIdentifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item);
            // Symbol: LParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: MaybeParamDeclList
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 6].item);
            // Symbol: RParen
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: MaybeByteAlign
            const arg7 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybeLinkSection
            const arg8 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: Bang
            const arg9 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg10 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 9;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.FnProto);
                node.cc_token = arg1;
                node.fn_token = arg2;
                node.name_token = arg3;
                node.params = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.align_expr = arg7;
                node.section_expr = arg8;
                node.return_type = Node.FnProto.ReturnType{ .InferErrorSet = arg10 };
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .FnProto };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.FnProto;
        },
        38 => {
            // Symbol: FnProto
            var result: *Node.FnProto = undefined;
            // Symbol: MaybeFnCC
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 9].item);
            // Symbol: Keyword_fn
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item).?;
            // Symbol: MaybeIdentifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item);
            // Symbol: LParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeParamDeclList
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: RParen
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: MaybeByteAlign
            const arg7 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybeLinkSection
            const arg8 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Keyword_var
            const arg9 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 8;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const vnode = try parser.createNode(Node.VarType);
                vnode.token = arg9;
                const node = try parser.createNode(Node.FnProto);
                node.cc_token = arg1;
                node.fn_token = arg2;
                node.name_token = arg3;
                node.params = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.align_expr = arg7;
                node.section_expr = arg8;
                node.return_type = Node.FnProto.ReturnType{ .Explicit = &vnode.base };
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .FnProto };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.FnProto;
        },
        39 => {
            // Symbol: FnProto
            var result: *Node.FnProto = undefined;
            // Symbol: MaybeFnCC
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 10].item);
            // Symbol: Keyword_fn
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 9].item).?;
            // Symbol: MaybeIdentifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item);
            // Symbol: LParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: MaybeParamDeclList
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 6].item);
            // Symbol: RParen
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: MaybeByteAlign
            const arg7 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybeLinkSection
            const arg8 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: Bang
            const arg9 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Keyword_var
            const arg10 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 9;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const vnode = try parser.createNode(Node.VarType);
                vnode.token = arg10;
                const node = try parser.createNode(Node.FnProto);
                node.cc_token = arg1;
                node.fn_token = arg2;
                node.name_token = arg3;
                node.params = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.align_expr = arg7;
                node.section_expr = arg8;
                node.return_type = Node.FnProto.ReturnType{ .InferErrorSet = &vnode.base };
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .FnProto };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.FnProto;
        },
        40 => {
            // Symbol: VarDecl
            var result: *Node = undefined;
            // Symbol: Keyword_const
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeColonTypeExpr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: MaybeByteAlign
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybeLinkSection
            const arg5 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybeEqualExpr
            const arg6 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Semicolon
            const arg7 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 6;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.VarDecl);
                node.mut_token = arg1;
                node.name_token = arg2;
                node.type_node = arg3;
                node.align_node = arg4;
                node.section_node = arg5;
                node.init_node = arg6;
                node.semicolon_token = arg7;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .VarDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.VarDecl;
        },
        41 => {
            // Symbol: VarDecl
            var result: *Node = undefined;
            // Symbol: Keyword_var
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeColonTypeExpr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: MaybeByteAlign
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybeLinkSection
            const arg5 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybeEqualExpr
            const arg6 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Semicolon
            const arg7 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 6;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.VarDecl);
                node.mut_token = arg1;
                node.name_token = arg2;
                node.type_node = arg3;
                node.align_node = arg4;
                node.section_node = arg5;
                node.init_node = arg6;
                node.semicolon_token = arg7;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .VarDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.VarDecl;
        },
        42 => {
            // Symbol: ContainerField
            var result: *Node = undefined;
            // Symbol: Identifier
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeColonTypeExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: MaybeEqualExpr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item);

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ContainerField);
                node.name_token = arg1;
                node.type_expr = arg2;
                node.value_expr = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerField };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerField;
        },
        43 => {
            // Symbol: MaybeStatements
            var result: ?*NodeList = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeStatements } });
            return TerminalId.MaybeStatements;
        },
        44 => {
            // Symbol: MaybeStatements
            var result: ?*NodeList = null;
            // Symbol: Statements
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeStatements };
            return TerminalId.MaybeStatements;
        },
        45 => {
            // Symbol: Statements
            var result: *NodeList = undefined;
            // Symbol: Statement
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithNode(NodeList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statements };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statements;
        },
        46 => {
            // Symbol: Statements
            var result: *NodeList = undefined;
            // Symbol: Statements
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Statement
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg2);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statements };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statements;
        },
        47 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: Keyword_comptime
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: VarDecl
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Comptime);
                node.comptime_token = arg1;
                node.expr = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statement;
        },
        48 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: VarDecl
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            return TerminalId.Statement;
        },
        49 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: Keyword_comptime
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BlockExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Comptime);
                node.comptime_token = arg1;
                node.expr = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statement;
        },
        50 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: Keyword_suspend
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Suspend);
                node.suspend_token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statement;
        },
        51 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: Keyword_suspend
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BlockExprStatement
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Suspend);
                node.suspend_token = arg1;
                node.body = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statement;
        },
        52 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: Keyword_defer
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BlockExprStatement
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Defer);
                node.defer_token = arg1;
                node.expr = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statement;
        },
        53 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: Keyword_errdefer
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BlockExprStatement
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Defer);
                node.defer_token = arg1;
                node.expr = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statement;
        },
        54 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: IfStatement
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            return TerminalId.Statement;
        },
        55 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: MaybeInline
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: ForStatement
            const arg2 = @intToPtr(?*Node.For, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
                arg2.inline_token = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statement;
        },
        56 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: MaybeInline
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: WhileStatement
            const arg2 = @intToPtr(?*Node.While, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
                arg2.inline_token = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statement;
        },
        57 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: LabeledStatement
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            return TerminalId.Statement;
        },
        58 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: SwitchExpr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            return TerminalId.Statement;
        },
        59 => {
            // Symbol: Statement
            var result: *Node = undefined;
            // Symbol: AssignExpr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Statement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Statement;
        },
        60 => {
            // Symbol: IfStatement
            var result: *Node = undefined;
            // Symbol: IfPrefix
            const arg1 = @intToPtr(?*Node.If, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BlockExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
                arg1.body = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .IfStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.IfStatement;
        },
        61 => {
            // Symbol: IfStatement
            var result: *Node = undefined;
            // Symbol: IfPrefix
            const arg1 = @intToPtr(?*Node.If, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: BlockExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: ElseStatement
            const arg3 = @intToPtr(?*Node.Else, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
                arg1.body = arg2;
                arg1.@"else" = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .IfStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.IfStatement;
        },
        62 => {
            // Symbol: IfStatement
            var result: *Node = undefined;
            // Symbol: IfPrefix
            const arg1 = @intToPtr(?*Node.If, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AssignExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
                arg1.body = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .IfStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.IfStatement;
        },
        63 => {
            // Symbol: IfStatement
            var result: *Node = undefined;
            // Symbol: IfPrefix
            const arg1 = @intToPtr(?*Node.If, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AssignExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: ElseStatement
            const arg3 = @intToPtr(?*Node.Else, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
                arg1.body = arg2;
                arg1.@"else" = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .IfStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.IfStatement;
        },
        64 => {
            // Symbol: ElseStatement
            var result: *Node.Else = undefined;
            // Symbol: Keyword_else
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybePayload
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Statement
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Else);
                node.else_token = arg1;
                node.payload = arg2;
                node.body = arg3;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ElseStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ElseStatement;
        },
        65 => {
            // Symbol: LabeledStatement
            var result: *Node = undefined;
            // Symbol: BlockLabel
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeInline
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: ForStatement
            const arg3 = @intToPtr(?*Node.For, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg3.base;
                arg3.label = arg1;
                arg3.inline_token = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .LabeledStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.LabeledStatement;
        },
        66 => {
            // Symbol: LabeledStatement
            var result: *Node = undefined;
            // Symbol: BlockLabel
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeInline
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: WhileStatement
            const arg3 = @intToPtr(?*Node.While, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg3.base;
                arg3.label = arg1;
                arg3.inline_token = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .LabeledStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.LabeledStatement;
        },
        67 => {
            // Symbol: LabeledStatement
            var result: *Node = undefined;
            // Symbol: BlockExpr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .LabeledStatement };
            return TerminalId.LabeledStatement;
        },
        68 => {
            // Symbol: ForStatement
            var result: *Node.For = undefined;
            // Symbol: ForPrefix
            const arg1 = @intToPtr(?*Node.For, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BlockExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                arg1.body = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ForStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ForStatement;
        },
        69 => {
            // Symbol: ForStatement
            var result: *Node.For = undefined;
            // Symbol: ForPrefix
            const arg1 = @intToPtr(?*Node.For, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: BlockExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: ElseNoPayloadStatement
            const arg3 = @intToPtr(?*Node.Else, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                arg1.body = arg2;
                arg1.@"else" = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ForStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ForStatement;
        },
        70 => {
            // Symbol: ForStatement
            var result: *Node.For = undefined;
            // Symbol: ForPrefix
            const arg1 = @intToPtr(?*Node.For, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AssignExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                arg1.body = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ForStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ForStatement;
        },
        71 => {
            // Symbol: ForStatement
            var result: *Node.For = undefined;
            // Symbol: ForPrefix
            const arg1 = @intToPtr(?*Node.For, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AssignExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: ElseNoPayloadStatement
            const arg3 = @intToPtr(?*Node.Else, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                arg1.body = arg2;
                arg1.@"else" = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ForStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ForStatement;
        },
        72 => {
            // Symbol: ElseNoPayloadStatement
            var result: *Node.Else = undefined;
            // Symbol: Keyword_else
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Statement
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Else);
                node.else_token = arg1;
                node.body = arg2;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ElseNoPayloadStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ElseNoPayloadStatement;
        },
        73 => {
            // Symbol: WhileStatement
            var result: *Node.While = undefined;
            // Symbol: WhilePrefix
            const arg1 = @intToPtr(?*Node.While, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BlockExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                arg1.body = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .WhileStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.WhileStatement;
        },
        74 => {
            // Symbol: WhileStatement
            var result: *Node.While = undefined;
            // Symbol: WhilePrefix
            const arg1 = @intToPtr(?*Node.While, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: BlockExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: ElseStatement
            const arg3 = @intToPtr(?*Node.Else, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                arg1.body = arg2;
                arg1.@"else" = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .WhileStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.WhileStatement;
        },
        75 => {
            // Symbol: WhileStatement
            var result: *Node.While = undefined;
            // Symbol: WhilePrefix
            const arg1 = @intToPtr(?*Node.While, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AssignExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                arg1.body = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .WhileStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.WhileStatement;
        },
        76 => {
            // Symbol: WhileStatement
            var result: *Node.While = undefined;
            // Symbol: WhilePrefix
            const arg1 = @intToPtr(?*Node.While, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AssignExpr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: ElseStatement
            const arg3 = @intToPtr(?*Node.Else, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                arg1.body = arg2;
                arg1.@"else" = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .WhileStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.WhileStatement;
        },
        77 => {
            // Symbol: BlockExprStatement
            var result: *Node = undefined;
            // Symbol: BlockExpr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .BlockExprStatement };
            return TerminalId.BlockExprStatement;
        },
        78 => {
            // Symbol: BlockExprStatement
            var result: *Node = undefined;
            // Symbol: AssignExpr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Semicolon
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .BlockExprStatement };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.BlockExprStatement;
        },
        79 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AsteriskEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignTimes;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        80 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: SlashEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignDiv;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        81 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: PercentEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignMod;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        82 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: PlusEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignPlus;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        83 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MinusEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignMinus;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        84 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AngleBracketAngleBracketLeftEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignBitShiftLeft;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        85 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AngleBracketAngleBracketRightEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignBitShiftRight;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        86 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AmpersandEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignBitAnd;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        87 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: CaretEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignBitXor;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        88 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: PipeEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignBitOr;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        89 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AsteriskPercentEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignTimesWrap;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        90 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: PlusPercentEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignPlusWrap;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        91 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MinusPercentEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AssignMinusWrap;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        92 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Equal
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .Assign;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AssignExpr;
        },
        93 => {
            // Symbol: AssignExpr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AssignExpr };
            return TerminalId.AssignExpr;
        },
        94 => {
            // Symbol: MaybeEqualExpr
            var result: ?*Node = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeEqualExpr } });
            return TerminalId.MaybeEqualExpr;
        },
        95 => {
            // Symbol: MaybeEqualExpr
            var result: ?*Node = null;
            // Symbol: Equal
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeEqualExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeEqualExpr;
        },
        96 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Recovery
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Recovery);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        97 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: LParen
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                if (arg2.id != .GroupedExpression) {
                    const node = try parser.createNode(Node.GroupedExpression);
                    node.lparen = arg1;
                    node.expr = arg2;
                    node.rparen = arg3;
                    result = &node.base;
                } else result = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        98 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Keyword_orelse
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .UnwrapOptional;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        99 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Keyword_catch
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybePayload
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Expr
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = Node.InfixOp.Op{ .Catch = arg3 };
                node.rhs = arg4;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        100 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Keyword_or
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .BoolOr;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        101 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AmpersandAmpersand
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                try parser.reportError(ParseError.AmpersandAmpersand, arg2);
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .BoolAnd;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        102 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Keyword_and
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .BoolAnd;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        103 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: EqualEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .EqualEqual;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        104 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: BangEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .BangEqual;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        105 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AngleBracketLeft
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .LessThan;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        106 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AngleBracketRight
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .GreaterThan;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        107 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AngleBracketLeftEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .LessOrEqual;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        108 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AngleBracketRightEqual
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .GreaterOrEqual;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        109 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Pipe
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .BitOr;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        110 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Caret
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .BitXor;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        111 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Ampersand
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .BitAnd;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        112 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AngleBracketAngleBracketLeft
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .BitShiftLeft;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        113 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AngleBracketAngleBracketRight
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .BitShiftRight;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        114 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Plus
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .Add;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        115 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Minus
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .Sub;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        116 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: PlusPlus
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .ArrayCat;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        117 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: PlusPercent
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .AddWrap;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        118 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MinusPercent
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .SubWrap;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        119 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Asterisk
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .Div;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        120 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Slash
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .Div;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        121 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Percent
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .Mod;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        122 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AsteriskAsterisk
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .ArrayMult;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        123 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AsteriskPercent
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .MultWrap;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        124 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: PipePipe
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .ErrorUnion;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        125 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Bang
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .BoolNot;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        126 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Minus
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .Negation;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        127 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: MinusPercent
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .NegationWrap;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        128 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Tilde
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .BitNot;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        129 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Ampersand
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .AddressOf;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        130 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_async
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .Async;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        131 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_try
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .Try;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        132 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_await
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .Await;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        133 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_comptime
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Comptime);
                node.comptime_token = arg1;
                node.expr = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        134 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: AsmExpr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            return TerminalId.Expr;
        },
        135 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_resume
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .Resume;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        136 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_cancel
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .Cancel;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        137 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_break
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ControlFlowExpression);
                node.ltoken = arg1;
                node.kind = Node.ControlFlowExpression.Kind{ .Break = null };
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        138 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_break
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BreakLabel
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ControlFlowExpression);
                node.ltoken = arg1;
                node.kind = Node.ControlFlowExpression.Kind{ .Break = arg2 };
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        139 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_break
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ControlFlowExpression);
                node.ltoken = arg1;
                node.kind = Node.ControlFlowExpression.Kind{ .Break = null };
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        140 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_break
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: BreakLabel
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ControlFlowExpression);
                node.ltoken = arg1;
                node.kind = Node.ControlFlowExpression.Kind{ .Break = arg2 };
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        141 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_continue
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ControlFlowExpression);
                node.ltoken = arg1;
                node.kind = Node.ControlFlowExpression.Kind{ .Continue = null };
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        142 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_continue
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: BreakLabel
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ControlFlowExpression);
                node.ltoken = arg1;
                node.kind = Node.ControlFlowExpression.Kind{ .Continue = arg2 };
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        143 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_return
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ControlFlowExpression);
                node.ltoken = arg1;
                node.kind = .Return;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        144 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_return
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ControlFlowExpression);
                node.ltoken = arg1;
                node.kind = .Return;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        145 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: LCurly
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RBrace
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.SuffixOp);
                node.lhs = arg1;
                node.op = Node.SuffixOp.Op{ .ArrayInitializer = NodeList.init(parser.allocator) };
                node.rtoken = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        146 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: LCurly
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: InitList
            const arg3 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeComma
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RBrace
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.SuffixOp);
                node.lhs = arg1;
                node.op = init: {
                    if (arg3.at(0).cast(Node.InfixOp)) |infix| {
                        switch (infix.op) {
                            // StructInitializer
                            .Assign => break :init Node.SuffixOp.Op{ .StructInitializer = arg3.* },
                            else => {},
                        }
                    }
                    // ArrayInitializer
                    break :init Node.SuffixOp.Op{ .ArrayInitializer = arg3.* };
                };
                node.rtoken = arg5;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        147 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: QuestionMark
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = .OptionalType;
                node.rhs = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        148 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_promise
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PromiseType);
                node.promise_token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        149 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_promise
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MinusAngleBracketRight
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PromiseType);
                node.promise_token = arg1;
                node.result = Node.PromiseType.Result{ .arrow_token = arg2, .return_type = arg3 };
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        150 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: LBracket
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: RBracket
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = Node.PrefixOp.Op{ .ArrayType = arg2 };
                node.rhs = arg4;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        151 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: LBracket
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: RBracket
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeAllowzero
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: MaybeAlign
            const arg4 = @intToPtr(?*Node.PrefixOp.PtrInfo.Align, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybeConst
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybeVolatile
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Expr
            const arg7 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 6;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = Node.PrefixOp.Op{ .SliceType = Node.PrefixOp.PtrInfo{ .allowzero_token = arg3, .align_info = if (arg4) |p| p.* else null, .const_token = arg5, .volatile_token = arg6 } };
                node.rhs = arg7;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        152 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Asterisk
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeAllowzero
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: MaybeAlign
            const arg3 = @intToPtr(?*Node.PrefixOp.PtrInfo.Align, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybeConst
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybeVolatile
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Expr
            const arg6 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = Node.PrefixOp.Op{ .PtrType = Node.PrefixOp.PtrInfo{ .allowzero_token = arg2, .align_info = if (arg3) |p| p.* else null, .const_token = arg4, .volatile_token = arg5 } };
                node.rhs = arg6;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        153 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: AsteriskAsterisk
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeAllowzero
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: MaybeAlign
            const arg3 = @intToPtr(?*Node.PrefixOp.PtrInfo.Align, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybeConst
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybeVolatile
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Expr
            const arg6 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                arg1.id = .Asterisk;
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = Node.PrefixOp.Op{ .PtrType = Node.PrefixOp.PtrInfo{ .allowzero_token = arg2, .align_info = if (arg3) |p| p.* else null, .const_token = arg4, .volatile_token = arg5 } };
                node.rhs = arg6;
                const outer = try parser.createNode(Node.PrefixOp);
                outer.op_token = arg1;
                outer.op = Node.PrefixOp.Op{ .PtrType = Node.PrefixOp.PtrInfo{ .allowzero_token = null, .align_info = null, .const_token = null, .volatile_token = null } };
                outer.rhs = &node.base;
                result = &outer.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        154 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: BracketStarBracket
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeAllowzero
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: MaybeAlign
            const arg3 = @intToPtr(?*Node.PrefixOp.PtrInfo.Align, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybeConst
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybeVolatile
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Expr
            const arg6 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = Node.PrefixOp.Op{ .PtrType = Node.PrefixOp.PtrInfo{ .allowzero_token = arg2, .align_info = if (arg3) |p| p.* else null, .const_token = arg4, .volatile_token = arg5 } };
                node.rhs = arg6;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        155 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: BracketStarCBracket
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeAllowzero
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: MaybeAlign
            const arg3 = @intToPtr(?*Node.PrefixOp.PtrInfo.Align, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: MaybeConst
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: MaybeVolatile
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Expr
            const arg6 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.PrefixOp);
                node.op_token = arg1;
                node.op = Node.PrefixOp.Op{ .PtrType = Node.PrefixOp.PtrInfo{ .allowzero_token = arg2, .align_info = if (arg3) |p| p.* else null, .const_token = arg4, .volatile_token = arg5 } };
                node.rhs = arg6;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        156 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: BlockExpr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            return TerminalId.Expr;
        },
        157 => {
            // Symbol: BlockExpr
            var result: *Node = undefined;
            // Symbol: Block
            const arg1 = @intToPtr(?*Node.Block, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .BlockExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.BlockExpr;
        },
        158 => {
            // Symbol: BlockExpr
            var result: *Node = undefined;
            // Symbol: BlockLabel
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Block
            const arg2 = @intToPtr(?*Node.Block, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
                arg2.label = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .BlockExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.BlockExpr;
        },
        159 => {
            // Symbol: Block
            var result: *Node.Block = undefined;
            // Symbol: LBrace
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeStatements
            const arg2 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RBrace
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Block);
                node.lbrace = arg1;
                node.statements = if (arg2) |p| p.* else NodeList.init(parser.allocator);
                node.rbrace = arg3;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Block };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Block;
        },
        160 => {
            // Symbol: BlockLabel
            var result: *Token = undefined;
            // Symbol: Identifier
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Colon
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .BlockLabel };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.BlockLabel;
        },
        161 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Bang
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .ErrorUnion;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        162 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Identifier
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Identifier);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        163 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: CharLiteral
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.CharLiteral);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        164 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: FloatLiteral
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.FloatLiteral);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        165 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: IntegerLiteral
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.IntegerLiteral);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        166 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: StringLiteral
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.StringLiteral);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        167 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: MultilineStringLiteral
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.MultilineStringLiteral);
                node.lines = arg1.*;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        168 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: MultilineCStringLiteral
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.MultilineStringLiteral);
                node.lines = arg1.*;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        169 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Period
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.EnumLiteral);
                node.dot = arg1;
                node.name = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        170 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_error
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Period
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Identifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const err = try parser.createNode(Node.ErrorType);
                err.token = arg1;
                const name = try parser.createNode(Node.Identifier);
                name.token = arg3;
                const infix = try parser.createNode(Node.InfixOp);
                infix.lhs = &err.base;
                infix.op_token = arg2;
                infix.op = .Period;
                infix.rhs = &name.base;
                result = &infix.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        171 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_error
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: LCurly
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RBrace
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const error_set = try parser.createNode(Node.ErrorSetDecl);
                error_set.error_token = arg1;
                error_set.decls = NodeList.init(parser.allocator);
                error_set.rbrace_token = arg3;
                result = &error_set.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        172 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_error
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: LCurly
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: ErrorTagList
            const arg3 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeComma
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RBrace
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const error_set = try parser.createNode(Node.ErrorSetDecl);
                error_set.error_token = arg1;
                error_set.decls = arg3.*;
                error_set.rbrace_token = arg5;
                result = &error_set.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        173 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_false
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.BoolLiteral);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        174 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_true
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.BoolLiteral);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        175 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_null
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.NullLiteral);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        176 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_undefined
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.UndefinedLiteral);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        177 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Keyword_unreachable
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Unreachable);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        178 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: SwitchExpr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            return TerminalId.Expr;
        },
        179 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: IfPrefix
            const arg1 = @intToPtr(?*Node.If, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
                arg1.body = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        180 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: IfPrefix
            const arg1 = @intToPtr(?*Node.If, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Keyword_else
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybePayload
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Expr
            const arg5 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
                const node = try parser.createNode(Node.Else);
                node.else_token = arg3;
                node.payload = arg4;
                node.body = arg5;
                arg1.body = arg2;
                arg1.@"else" = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        181 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Builtin
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeExprList
            const arg3 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.BuiltinCall);
                node.builtin_token = arg1;
                node.params = if (arg3) |p| p.* else NodeList.init(parser.allocator);
                node.rparen_token = arg4;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        182 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: FnProto
            const arg1 = @intToPtr(?*Node.FnProto, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        183 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LBracket
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RBracket
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.SuffixOp);
                node.lhs = arg1;
                node.op = Node.SuffixOp.Op{ .ArrayAccess = arg3 };
                node.rtoken = arg4;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        184 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: LBracket
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Ellipsis2
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RBracket
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.SuffixOp);
                node.lhs = arg1;
                node.op = Node.SuffixOp.Op{ .Slice = Node.SuffixOp.Op.Slice{ .start = arg3, .end = null } };
                node.rtoken = arg5;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        185 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: LBracket
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Ellipsis2
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg5 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RBracket
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.SuffixOp);
                node.lhs = arg1;
                node.op = Node.SuffixOp.Op{ .Slice = Node.SuffixOp.Op.Slice{ .start = arg3, .end = arg5 } };
                node.rtoken = arg6;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        186 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Period
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Identifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg3;
                const infix = try parser.createNode(Node.InfixOp);
                infix.lhs = arg1;
                infix.op_token = arg2;
                infix.op = .Period;
                infix.rhs = &name.base;
                result = &infix.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        187 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: PeriodAsterisk
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.SuffixOp);
                node.lhs = arg1;
                node.op = .Deref;
                node.rtoken = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        188 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: PeriodQuestionMark
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.SuffixOp);
                node.lhs = arg1;
                node.op = .UnwrapOptional;
                node.rtoken = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        189 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeExprList
            const arg3 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.SuffixOp);
                node.lhs = arg1;
                node.op = Node.SuffixOp.Op{ .Call = Node.SuffixOp.Op.Call{ .params = if (arg3) |p| p.* else NodeList.init(parser.allocator) } };
                node.rtoken = arg4;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Expr;
        },
        190 => {
            // Symbol: Expr
            var result: *Node = undefined;
            // Symbol: ContainerDecl
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Expr };
            return TerminalId.Expr;
        },
        191 => {
            // Symbol: ContainerDecl
            var result: *Node = undefined;
            // Symbol: MaybeExternPacked
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: ContainerDeclOp
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LBrace
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeContainerMembers
            const arg4 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RBrace
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ContainerDecl);
                node.layout_token = arg1;
                node.kind_token = arg2;
                node.init_arg_expr = .None;
                node.lbrace_token = arg3;
                node.fields_and_decls = if (arg4) |p| p.* else NodeList.init(parser.allocator);
                node.rbrace_token = arg5;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerDecl;
        },
        192 => {
            // Symbol: ContainerDecl
            var result: *Node = undefined;
            // Symbol: MaybeExternPacked
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item);
            // Symbol: Keyword_enum
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: ContainerDeclTypeType
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LBrace
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeContainerMembers
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RBrace
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ContainerDecl);
                node.layout_token = arg1;
                node.kind_token = arg2;
                node.init_arg_expr = Node.ContainerDecl.InitArg{ .Type = arg3 };
                node.lbrace_token = arg4;
                node.fields_and_decls = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.rbrace_token = arg6;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerDecl;
        },
        193 => {
            // Symbol: ContainerDecl
            var result: *Node = undefined;
            // Symbol: MaybeExternPacked
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item);
            // Symbol: Keyword_union
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: ContainerDeclTypeType
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LBrace
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeContainerMembers
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RBrace
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ContainerDecl);
                node.layout_token = arg1;
                node.kind_token = arg2;
                node.init_arg_expr = Node.ContainerDecl.InitArg{ .Type = arg3 };
                node.lbrace_token = arg4;
                node.fields_and_decls = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.rbrace_token = arg6;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerDecl;
        },
        194 => {
            // Symbol: ContainerDecl
            var result: *Node = undefined;
            // Symbol: MaybeExternPacked
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item);
            // Symbol: Keyword_union
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: ContainerDeclTypeEnum
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: LBrace
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeContainerMembers
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RBrace
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ContainerDecl);
                node.layout_token = arg1;
                node.kind_token = arg2;
                node.init_arg_expr = Node.ContainerDecl.InitArg{ .Enum = arg3 };
                node.lbrace_token = arg4;
                node.fields_and_decls = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.rbrace_token = arg6;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerDecl;
        },
        195 => {
            // Symbol: MaybeExternPacked
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeExternPacked } });
            return TerminalId.MaybeExternPacked;
        },
        196 => {
            // Symbol: MaybeExternPacked
            var result: ?*Token = null;
            // Symbol: Keyword_extern
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeExternPacked };
            return TerminalId.MaybeExternPacked;
        },
        197 => {
            // Symbol: MaybeExternPacked
            var result: ?*Token = null;
            // Symbol: Keyword_packed
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeExternPacked };
            return TerminalId.MaybeExternPacked;
        },
        198 => {
            // Symbol: SwitchExpr
            var result: *Node = undefined;
            // Symbol: Keyword_switch
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: LBrace
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: SwitchProngList
            const arg6 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeComma
            const arg7 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RBrace
            const arg8 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 7;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Switch);
                node.switch_token = arg1;
                node.expr = arg3;
                node.cases = arg6.*;
                node.rbrace = arg8;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.SwitchExpr;
        },
        199 => {
            // Symbol: String
            var result: *Node = undefined;
            // Symbol: StringLiteral
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.StringLiteral);
                node.token = arg1;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .String };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.String;
        },
        200 => {
            // Symbol: String
            var result: *Node = undefined;
            // Symbol: MultilineStringLiteral
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.MultilineStringLiteral);
                node.lines = arg1.*;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .String };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.String;
        },
        201 => {
            // Symbol: String
            var result: *Node = undefined;
            // Symbol: MultilineCStringLiteral
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.MultilineStringLiteral);
                node.lines = arg1.*;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .String };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.String;
        },
        202 => {
            // Symbol: AsmExpr
            var result: *Node = undefined;
            // Symbol: Keyword_asm
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: MaybeVolatile
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: LParen
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: String
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Asm);
                node.asm_token = arg1;
                node.volatile_token = arg2;
                node.template = arg4;
                node.outputs = NodeList.init(parser.allocator);
                node.inputs = NodeList.init(parser.allocator);
                node.clobbers = NodeList.init(parser.allocator);
                node.rparen = arg5;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmExpr;
        },
        203 => {
            // Symbol: AsmExpr
            var result: *Node = undefined;
            // Symbol: Keyword_asm
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybeVolatile
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: LParen
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: String
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AsmOutput
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RParen
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Asm);
                node.asm_token = arg1;
                node.volatile_token = arg2;
                node.template = arg4;
                node.outputs = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.inputs = NodeList.init(parser.allocator);
                node.clobbers = NodeList.init(parser.allocator);
                node.rparen = arg6;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmExpr;
        },
        204 => {
            // Symbol: AsmExpr
            var result: *Node = undefined;
            // Symbol: Keyword_asm
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: MaybeVolatile
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item);
            // Symbol: LParen
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: String
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: AsmOutput
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: AsmInput
            const arg6 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RParen
            const arg7 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 6;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Asm);
                node.asm_token = arg1;
                node.volatile_token = arg2;
                node.template = arg4;
                node.outputs = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.inputs = if (arg6) |p| p.* else NodeList.init(parser.allocator);
                node.clobbers = NodeList.init(parser.allocator);
                node.rparen = arg7;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmExpr;
        },
        205 => {
            // Symbol: AsmExpr
            var result: *Node = undefined;
            // Symbol: Keyword_asm
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item).?;
            // Symbol: MaybeVolatile
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item);
            // Symbol: LParen
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: String
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: AsmOutput
            const arg5 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: AsmInput
            const arg6 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item);
            // Symbol: AsmClobber
            const arg7 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RParen
            const arg8 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 7;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Asm);
                node.asm_token = arg1;
                node.volatile_token = arg2;
                node.template = arg4;
                node.outputs = if (arg5) |p| p.* else NodeList.init(parser.allocator);
                node.inputs = if (arg6) |p| p.* else NodeList.init(parser.allocator);
                node.clobbers = if (arg7) |p| p.* else NodeList.init(parser.allocator);
                node.rparen = arg8;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmExpr;
        },
        206 => {
            // Symbol: AsmOutput
            var result: ?*NodeList = null;
            // Symbol: Colon
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = null;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmOutput };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmOutput;
        },
        207 => {
            // Symbol: AsmOutput
            var result: ?*NodeList = null;
            // Symbol: Colon
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: AsmOutputList
            const arg2 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmOutput };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmOutput;
        },
        208 => {
            // Symbol: AsmOutputItem
            var result: *Node = undefined;
            // Symbol: LBracket
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: RBracket
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: String
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LParen
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Identifier
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg7 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 6;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg2;
                const variable = try parser.createNode(Node.Identifier);
                variable.token = arg6;
                const node = try parser.createNode(Node.AsmOutput);
                node.lbracket = arg1;
                node.symbolic_name = &name.base;
                node.constraint = arg4;
                node.kind = Node.AsmOutput.Kind{ .Variable = variable };
                node.rparen = arg7;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmOutputItem };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmOutputItem;
        },
        209 => {
            // Symbol: AsmOutputItem
            var result: *Node = undefined;
            // Symbol: LBracket
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: RBracket
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: String
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: LParen
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: MinusAngleBracketRight
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg7 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg8 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 7;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg2;
                const node = try parser.createNode(Node.AsmOutput);
                node.lbracket = arg1;
                node.symbolic_name = &name.base;
                node.constraint = arg4;
                node.kind = Node.AsmOutput.Kind{ .Return = arg7 };
                node.rparen = arg8;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmOutputItem };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmOutputItem;
        },
        210 => {
            // Symbol: AsmInput
            var result: ?*NodeList = null;
            // Symbol: Colon
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = null;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmInput };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmInput;
        },
        211 => {
            // Symbol: AsmInput
            var result: ?*NodeList = null;
            // Symbol: Colon
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: AsmInputList
            const arg2 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmInput };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmInput;
        },
        212 => {
            // Symbol: AsmInputItem
            var result: *Node = undefined;
            // Symbol: LBracket
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: RBracket
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: String
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LParen
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg6 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg7 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 6;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg2;
                const node = try parser.createNode(Node.AsmInput);
                node.lbracket = arg1;
                node.symbolic_name = &name.base;
                node.constraint = arg4;
                node.expr = arg6;
                node.rparen = arg7;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmInputItem };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmInputItem;
        },
        213 => {
            // Symbol: AsmClobber
            var result: ?*NodeList = null;
            // Symbol: Colon
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = null;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmClobber };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmClobber;
        },
        214 => {
            // Symbol: AsmClobber
            var result: ?*NodeList = null;
            // Symbol: Colon
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: StringList
            const arg2 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmClobber };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmClobber;
        },
        215 => {
            // Symbol: BreakLabel
            var result: *Node = undefined;
            // Symbol: Colon
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Identifier);
                node.token = arg2;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .BreakLabel };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.BreakLabel;
        },
        216 => {
            // Symbol: MaybeLinkSection
            var result: ?*Node = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeLinkSection } });
            return TerminalId.MaybeLinkSection;
        },
        217 => {
            // Symbol: MaybeLinkSection
            var result: ?*Node = null;
            // Symbol: Keyword_linksection
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeLinkSection };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeLinkSection;
        },
        218 => {
            // Symbol: MaybeFnCC
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeFnCC } });
            return TerminalId.MaybeFnCC;
        },
        219 => {
            // Symbol: MaybeFnCC
            var result: ?*Token = null;
            // Symbol: Keyword_nakedcc
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeFnCC };
            return TerminalId.MaybeFnCC;
        },
        220 => {
            // Symbol: MaybeFnCC
            var result: ?*Token = null;
            // Symbol: Keyword_stdcallcc
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeFnCC };
            return TerminalId.MaybeFnCC;
        },
        221 => {
            // Symbol: MaybeFnCC
            var result: ?*Token = null;
            // Symbol: Keyword_extern
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeFnCC };
            return TerminalId.MaybeFnCC;
        },
        222 => {
            // Symbol: MaybeFnCC
            var result: ?*Token = null;
            // Symbol: Keyword_async
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeFnCC };
            return TerminalId.MaybeFnCC;
        },
        223 => {
            // Symbol: ParamDecl
            var result: *Node.ParamDecl = undefined;
            // Symbol: MaybeNoalias
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: ParamType
            const arg2 = @intToPtr(?*Node.ParamDecl, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg2;
                arg2.noalias_token = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ParamDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ParamDecl;
        },
        224 => {
            // Symbol: ParamDecl
            var result: *Node.ParamDecl = undefined;
            // Symbol: MaybeNoalias
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item);
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Colon
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: ParamType
            const arg4 = @intToPtr(?*Node.ParamDecl, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg4;
                arg4.noalias_token = arg1;
                arg4.name_token = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ParamDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ParamDecl;
        },
        225 => {
            // Symbol: ParamDecl
            var result: *Node.ParamDecl = undefined;
            // Symbol: MaybeNoalias
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: Keyword_comptime
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Identifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Colon
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: ParamType
            const arg5 = @intToPtr(?*Node.ParamDecl, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg5;
                arg5.noalias_token = arg1;
                arg5.comptime_token = arg2;
                arg5.name_token = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ParamDecl };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ParamDecl;
        },
        226 => {
            // Symbol: ParamType
            var result: *Node.ParamDecl = undefined;
            // Symbol: Keyword_var
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const vtype = try parser.createNode(Node.VarType);
                vtype.token = arg1;
                const node = try parser.createNode(Node.ParamDecl);
                node.type_node = &vtype.base;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ParamType };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ParamType;
        },
        227 => {
            // Symbol: ParamType
            var result: *Node.ParamDecl = undefined;
            // Symbol: Ellipsis3
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ParamDecl);
                node.var_args_token = arg1;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ParamType };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ParamType;
        },
        228 => {
            // Symbol: ParamType
            var result: *Node.ParamDecl = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ParamDecl);
                node.type_node = arg1;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ParamType };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ParamType;
        },
        229 => {
            // Symbol: IfPrefix
            var result: *Node.If = undefined;
            // Symbol: Keyword_if
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: MaybePtrPayload
            const arg5 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item);

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.If);
                node.if_token = arg1;
                node.condition = arg3;
                node.payload = arg5;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .IfPrefix };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.IfPrefix;
        },
        230 => {
            // Symbol: ForPrefix
            var result: *Node.For = undefined;
            // Symbol: Keyword_for
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: PtrIndexPayload
            const arg5 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.For);
                node.for_token = arg1;
                node.array_expr = arg3;
                node.payload = arg5;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ForPrefix };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ForPrefix;
        },
        231 => {
            // Symbol: WhilePrefix
            var result: *Node.While = undefined;
            // Symbol: Keyword_while
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: MaybePtrPayload
            const arg5 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item);

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.While);
                node.while_token = arg1;
                node.condition = arg3;
                node.payload = arg5;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .WhilePrefix };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.WhilePrefix;
        },
        232 => {
            // Symbol: WhilePrefix
            var result: *Node.While = undefined;
            // Symbol: Keyword_while
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 9].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: MaybePtrPayload
            const arg5 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 5].item);
            // Symbol: Colon
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LParen
            const arg7 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: AssignExpr
            const arg8 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg9 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 8;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.While);
                node.while_token = arg1;
                node.condition = arg3;
                node.payload = arg5;
                node.continue_expr = arg8;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .WhilePrefix };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.WhilePrefix;
        },
        233 => {
            // Symbol: MaybePayload
            var result: ?*Node = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybePayload } });
            return TerminalId.MaybePayload;
        },
        234 => {
            // Symbol: MaybePayload
            var result: ?*Node = null;
            // Symbol: Pipe
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Pipe
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg2;
                const node = try parser.createNode(Node.Payload);
                node.lpipe = arg1;
                node.error_symbol = &name.base;
                node.rpipe = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybePayload };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybePayload;
        },
        235 => {
            // Symbol: MaybePtrPayload
            var result: ?*Node = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybePtrPayload } });
            return TerminalId.MaybePtrPayload;
        },
        236 => {
            // Symbol: MaybePtrPayload
            var result: ?*Node = null;
            // Symbol: Pipe
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Pipe
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg2;
                const node = try parser.createNode(Node.PointerPayload);
                node.lpipe = arg1;
                node.value_symbol = &name.base;
                node.rpipe = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybePtrPayload };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybePtrPayload;
        },
        237 => {
            // Symbol: MaybePtrPayload
            var result: ?*Node = null;
            // Symbol: Pipe
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Asterisk
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Identifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Pipe
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg3;
                const node = try parser.createNode(Node.PointerPayload);
                node.lpipe = arg1;
                node.ptr_token = arg2;
                node.value_symbol = &name.base;
                node.rpipe = arg4;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybePtrPayload };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybePtrPayload;
        },
        238 => {
            // Symbol: PtrIndexPayload
            var result: *Node = undefined;
            // Symbol: Pipe
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Pipe
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg2;
                const node = try parser.createNode(Node.PointerIndexPayload);
                node.lpipe = arg1;
                node.value_symbol = &name.base;
                node.rpipe = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .PtrIndexPayload };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.PtrIndexPayload;
        },
        239 => {
            // Symbol: PtrIndexPayload
            var result: *Node = undefined;
            // Symbol: Pipe
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Asterisk
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Identifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Pipe
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg3;
                const node = try parser.createNode(Node.PointerIndexPayload);
                node.lpipe = arg1;
                node.ptr_token = arg2;
                node.value_symbol = &name.base;
                node.rpipe = arg4;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .PtrIndexPayload };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.PtrIndexPayload;
        },
        240 => {
            // Symbol: PtrIndexPayload
            var result: *Node = undefined;
            // Symbol: Pipe
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Comma
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Identifier
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Pipe
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg2;
                const index = try parser.createNode(Node.Identifier);
                index.token = arg4;
                const node = try parser.createNode(Node.PointerIndexPayload);
                node.lpipe = arg1;
                node.value_symbol = &name.base;
                node.index_symbol = &index.base;
                node.rpipe = arg5;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .PtrIndexPayload };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.PtrIndexPayload;
        },
        241 => {
            // Symbol: PtrIndexPayload
            var result: *Node = undefined;
            // Symbol: Pipe
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: Asterisk
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: Identifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Comma
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Identifier
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Pipe
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const name = try parser.createNode(Node.Identifier);
                name.token = arg3;
                const index = try parser.createNode(Node.Identifier);
                index.token = arg5;
                const node = try parser.createNode(Node.PointerIndexPayload);
                node.lpipe = arg1;
                node.ptr_token = arg2;
                node.value_symbol = &name.base;
                node.index_symbol = &index.base;
                node.rpipe = arg6;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .PtrIndexPayload };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.PtrIndexPayload;
        },
        242 => {
            // Symbol: SwitchProng
            var result: *Node = undefined;
            // Symbol: SwitchCase
            const arg1 = @intToPtr(?*Node.SwitchCase, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: EqualAngleBracketRight
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybePtrPayload
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: AssignExpr
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg1.base;
                arg1.arrow_token = arg2;
                arg1.payload = arg3;
                arg1.expr = arg4;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchProng };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.SwitchProng;
        },
        243 => {
            // Symbol: SwitchCase
            var result: *Node.SwitchCase = undefined;
            // Symbol: Keyword_else
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const else_node = try parser.createNode(Node.SwitchElse);
                else_node.token = arg1;
                const node = try parser.createNode(Node.SwitchCase);
                node.items = NodeList.init(parser.allocator);
                try node.items.append(&else_node.base);
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchCase };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.SwitchCase;
        },
        244 => {
            // Symbol: SwitchCase
            var result: *Node.SwitchCase = undefined;
            // Symbol: SwitchItems
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: MaybeComma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item);

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.SwitchCase);
                node.items = arg1.*;
                result = node;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchCase };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.SwitchCase;
        },
        245 => {
            // Symbol: SwitchItems
            var result: *NodeList = undefined;
            // Symbol: SwitchItem
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithNode(NodeList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchItems };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.SwitchItems;
        },
        246 => {
            // Symbol: SwitchItems
            var result: *NodeList = undefined;
            // Symbol: SwitchItems
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: SwitchItem
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg3);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchItems };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.SwitchItems;
        },
        247 => {
            // Symbol: SwitchItem
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchItem };
            return TerminalId.SwitchItem;
        },
        248 => {
            // Symbol: SwitchItem
            var result: *Node = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Ellipsis3
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.InfixOp);
                node.lhs = arg1;
                node.op_token = arg2;
                node.op = .Range;
                node.rhs = arg3;
                result = &node.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchItem };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.SwitchItem;
        },
        249 => {
            // Symbol: MaybeVolatile
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeVolatile } });
            return TerminalId.MaybeVolatile;
        },
        250 => {
            // Symbol: MaybeVolatile
            var result: ?*Token = null;
            // Symbol: Keyword_volatile
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeVolatile };
            return TerminalId.MaybeVolatile;
        },
        251 => {
            // Symbol: MaybeAllowzero
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeAllowzero } });
            return TerminalId.MaybeAllowzero;
        },
        252 => {
            // Symbol: MaybeAllowzero
            var result: ?*Token = null;
            // Symbol: Keyword_allowzero
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeAllowzero };
            return TerminalId.MaybeAllowzero;
        },
        253 => {
            // Symbol: ContainerDeclTypeEnum
            var result: ?*Node = null;
            // Symbol: LParen
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Keyword_enum
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDeclTypeEnum };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerDeclTypeEnum;
        },
        254 => {
            // Symbol: ContainerDeclTypeEnum
            var result: ?*Node = null;
            // Symbol: LParen
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: Keyword_enum
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: LParen
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Expr
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: RParen
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg4;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDeclTypeEnum };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerDeclTypeEnum;
        },
        255 => {
            // Symbol: ContainerDeclTypeType
            var result: *Node = undefined;
            // Symbol: LParen
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDeclTypeType };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ContainerDeclTypeType;
        },
        256 => {
            // Symbol: ContainerDeclOp
            var result: *Token = undefined;
            // Symbol: Keyword_struct
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDeclOp };
            return TerminalId.ContainerDeclOp;
        },
        257 => {
            // Symbol: ContainerDeclOp
            var result: *Token = undefined;
            // Symbol: Keyword_union
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDeclOp };
            return TerminalId.ContainerDeclOp;
        },
        258 => {
            // Symbol: ContainerDeclOp
            var result: *Token = undefined;
            // Symbol: Keyword_enum
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ContainerDeclOp };
            return TerminalId.ContainerDeclOp;
        },
        259 => {
            // Symbol: MaybeByteAlign
            var result: ?*Node = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeByteAlign } });
            return TerminalId.MaybeByteAlign;
        },
        260 => {
            // Symbol: MaybeByteAlign
            var result: ?*Node = null;
            // Symbol: Keyword_align
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeByteAlign };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeByteAlign;
        },
        261 => {
            // Symbol: MaybeAlign
            var result: ?*Node.PrefixOp.PtrInfo.Align = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeAlign } });
            return TerminalId.MaybeAlign;
        },
        262 => {
            // Symbol: MaybeAlign
            var result: ?*Node.PrefixOp.PtrInfo.Align = null;
            // Symbol: Keyword_align
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const value = try parser.createTemporary(Node.PrefixOp.PtrInfo.Align);
                value.node = arg3;
                result = value;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeAlign };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeAlign;
        },
        263 => {
            // Symbol: MaybeAlign
            var result: ?*Node.PrefixOp.PtrInfo.Align = null;
            // Symbol: Keyword_align
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: Colon
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: IntegerLiteral
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Colon
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: IntegerLiteral
            const arg7 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg8 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 7;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const start = try parser.createNode(Node.IntegerLiteral);
                start.token = arg5;
                const end = try parser.createNode(Node.IntegerLiteral);
                end.token = arg7;
                const value = try parser.createTemporary(Node.PrefixOp.PtrInfo.Align);
                value.node = arg3;
                value.bit_range = Node.PrefixOp.PtrInfo.Align.BitRange{ .start = &start.base, .end = &end.base };
                result = value;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeAlign };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeAlign;
        },
        264 => {
            // Symbol: MaybeAlign
            var result: ?*Node.PrefixOp.PtrInfo.Align = null;
            // Symbol: Keyword_align
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 8].item).?;
            // Symbol: LParen
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 7].item).?;
            // Symbol: Identifier
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: Colon
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: IntegerLiteral
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Colon
            const arg6 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: IntegerLiteral
            const arg7 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RParen
            const arg8 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 7;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.Identifier);
                node.token = arg3;
                const start = try parser.createNode(Node.IntegerLiteral);
                start.token = arg5;
                const end = try parser.createNode(Node.IntegerLiteral);
                end.token = arg7;
                const value = try parser.createTemporary(Node.PrefixOp.PtrInfo.Align);
                value.node = &node.base;
                value.bit_range = Node.PrefixOp.PtrInfo.Align.BitRange{ .start = &start.base, .end = &end.base };
                result = value;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeAlign };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeAlign;
        },
        265 => {
            // Symbol: ErrorTagList
            var result: *NodeList = undefined;
            // Symbol: MaybeDocComment
            const arg1 = @intToPtr(?*Node.DocComment, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.ErrorTag);
                node.doc_comments = arg1;
                node.name_token = arg2;
                result = try parser.createListWithNode(NodeList, &node.base);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ErrorTagList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ErrorTagList;
        },
        266 => {
            // Symbol: ErrorTagList
            var result: *NodeList = undefined;
            // Symbol: ErrorTagList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeDocComment
            const arg3 = @intToPtr(?*Node.DocComment, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: Identifier
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                const node = try parser.createNode(Node.ErrorTag);
                node.doc_comments = arg3;
                node.name_token = arg4;
                try arg1.append(&node.base);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ErrorTagList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ErrorTagList;
        },
        267 => {
            // Symbol: SwitchProngList
            var result: *NodeList = undefined;
            // Symbol: SwitchProng
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithNode(NodeList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchProngList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.SwitchProngList;
        },
        268 => {
            // Symbol: SwitchProngList
            var result: *NodeList = undefined;
            // Symbol: SwitchProngList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: SwitchProng
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg3);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .SwitchProngList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.SwitchProngList;
        },
        269 => {
            // Symbol: AsmOutputList
            var result: *NodeList = undefined;
            // Symbol: AsmOutputItem
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithNode(NodeList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmOutputList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmOutputList;
        },
        270 => {
            // Symbol: AsmOutputList
            var result: *NodeList = undefined;
            // Symbol: AsmOutputList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: AsmOutputItem
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg3);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmOutputList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmOutputList;
        },
        271 => {
            // Symbol: AsmInputList
            var result: *NodeList = undefined;
            // Symbol: AsmInputItem
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithNode(NodeList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmInputList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmInputList;
        },
        272 => {
            // Symbol: AsmInputList
            var result: *NodeList = undefined;
            // Symbol: AsmInputList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: AsmInputItem
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg3);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .AsmInputList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.AsmInputList;
        },
        273 => {
            // Symbol: StringList
            var result: *NodeList = undefined;
            // Symbol: StringLiteral
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.StringLiteral);
                node.token = arg1;
                result = try parser.createListWithNode(NodeList, &node.base);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .StringList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.StringList;
        },
        274 => {
            // Symbol: StringList
            var result: *NodeList = undefined;
            // Symbol: StringList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: StringLiteral
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                const node = try parser.createNode(Node.StringLiteral);
                node.token = arg3;
                try arg1.append(&node.base);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .StringList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.StringList;
        },
        275 => {
            // Symbol: MaybeParamDeclList
            var result: ?*NodeList = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeParamDeclList } });
            return TerminalId.MaybeParamDeclList;
        },
        276 => {
            // Symbol: MaybeParamDeclList
            var result: *NodeList = undefined;
            // Symbol: ParamDeclList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: MaybeComma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item);

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeParamDeclList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeParamDeclList;
        },
        277 => {
            // Symbol: ParamDeclList
            var result: *NodeList = undefined;
            // Symbol: MaybeDocComment
            const arg1 = @intToPtr(?*Node.DocComment, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: ParamDecl
            const arg2 = @intToPtr(?*Node.ParamDecl, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                arg2.doc_comments = arg1;
                result = try parser.createListWithNode(NodeList, &arg2.base);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ParamDeclList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ParamDeclList;
        },
        278 => {
            // Symbol: ParamDeclList
            var result: *NodeList = undefined;
            // Symbol: ParamDeclList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeDocComment
            const arg3 = @intToPtr(?*Node.DocComment, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: ParamDecl
            const arg4 = @intToPtr(?*Node.ParamDecl, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                arg4.doc_comments = arg3;
                try arg1.append(&arg4.base);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ParamDeclList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ParamDeclList;
        },
        279 => {
            // Symbol: MaybeExprList
            var result: ?*NodeList = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeExprList } });
            return TerminalId.MaybeExprList;
        },
        280 => {
            // Symbol: MaybeExprList
            var result: ?*NodeList = null;
            // Symbol: ExprList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: MaybeComma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item);

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeExprList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeExprList;
        },
        281 => {
            // Symbol: ExprList
            var result: *NodeList = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithNode(NodeList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ExprList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ExprList;
        },
        282 => {
            // Symbol: ExprList
            var result: *NodeList = undefined;
            // Symbol: ExprList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg3);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .ExprList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.ExprList;
        },
        283 => {
            // Symbol: InitList
            var result: *NodeList = undefined;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithNode(NodeList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .InitList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.InitList;
        },
        284 => {
            // Symbol: InitList
            var result: *NodeList = undefined;
            // Symbol: Period
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Identifier
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Equal
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg4 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 3;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const node = try parser.createNode(Node.FieldInitializer);
                node.period_token = arg1;
                node.name_token = arg2;
                node.expr = arg4;
                result = try parser.createListWithNode(NodeList, &node.base);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .InitList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.InitList;
        },
        285 => {
            // Symbol: InitList
            var result: *NodeList = undefined;
            // Symbol: InitList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg3 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg3);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .InitList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.InitList;
        },
        286 => {
            // Symbol: InitList
            var result: *NodeList = undefined;
            // Symbol: InitList
            const arg1 = @intToPtr(?*NodeList, parser.stack.items[parser.stack.len - 6].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: Period
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: Identifier
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Equal
            const arg5 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg6 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 5;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                const node = try parser.createNode(Node.FieldInitializer);
                node.period_token = arg3;
                node.name_token = arg4;
                node.expr = arg6;
                try arg1.append(&node.base);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .InitList };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.InitList;
        },
        287 => {
            // Symbol: MaybePub
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybePub } });
            return TerminalId.MaybePub;
        },
        288 => {
            // Symbol: MaybePub
            var result: ?*Token = null;
            // Symbol: Keyword_pub
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybePub };
            return TerminalId.MaybePub;
        },
        289 => {
            // Symbol: MaybeColonTypeExpr
            var result: ?*Node = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeColonTypeExpr } });
            return TerminalId.MaybeColonTypeExpr;
        },
        290 => {
            // Symbol: MaybeColonTypeExpr
            var result: ?*Node = null;
            // Symbol: Colon
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Expr
            const arg2 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg2;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeColonTypeExpr };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MaybeColonTypeExpr;
        },
        291 => {
            // Symbol: MaybeExpr
            var result: ?*Node = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeExpr } });
            return TerminalId.MaybeExpr;
        },
        292 => {
            // Symbol: MaybeExpr
            var result: ?*Node = null;
            // Symbol: Expr
            const arg1 = @intToPtr(?*Node, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeExpr };
            return TerminalId.MaybeExpr;
        },
        293 => {
            // Symbol: MaybeNoalias
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeNoalias } });
            return TerminalId.MaybeNoalias;
        },
        294 => {
            // Symbol: MaybeNoalias
            var result: ?*Token = null;
            // Symbol: Keyword_noalias
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeNoalias };
            return TerminalId.MaybeNoalias;
        },
        295 => {
            // Symbol: MaybeInline
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeInline } });
            return TerminalId.MaybeInline;
        },
        296 => {
            // Symbol: MaybeInline
            var result: ?*Token = null;
            // Symbol: Keyword_inline
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeInline };
            return TerminalId.MaybeInline;
        },
        297 => {
            // Symbol: MaybeIdentifier
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeIdentifier } });
            return TerminalId.MaybeIdentifier;
        },
        298 => {
            // Symbol: MaybeIdentifier
            var result: ?*Token = null;
            // Symbol: Identifier
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeIdentifier };
            return TerminalId.MaybeIdentifier;
        },
        299 => {
            // Symbol: MaybeComma
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeComma } });
            return TerminalId.MaybeComma;
        },
        300 => {
            // Symbol: MaybeComma
            var result: ?*Token = null;
            // Symbol: Comma
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeComma };
            return TerminalId.MaybeComma;
        },
        301 => {
            // Symbol: MaybeConst
            var result: ?*Token = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeConst } });
            return TerminalId.MaybeConst;
        },
        302 => {
            // Symbol: MaybeConst
            var result: ?*Token = null;
            // Symbol: Keyword_const
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeConst };
            return TerminalId.MaybeConst;
        },
        303 => {
            // Symbol: MultilineStringLiteral
            var result: *TokenList = undefined;
            // Symbol: LineString
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithToken(TokenList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MultilineStringLiteral };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MultilineStringLiteral;
        },
        304 => {
            // Symbol: MultilineStringLiteral
            var result: *TokenList = undefined;
            // Symbol: MultilineStringLiteral
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: LineString
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg2);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MultilineStringLiteral };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MultilineStringLiteral;
        },
        305 => {
            // Symbol: MultilineCStringLiteral
            var result: *TokenList = undefined;
            // Symbol: LineCString
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createListWithToken(TokenList, arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MultilineCStringLiteral };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MultilineCStringLiteral;
        },
        306 => {
            // Symbol: MultilineCStringLiteral
            var result: *TokenList = undefined;
            // Symbol: MultilineCStringLiteral
            const arg1 = @intToPtr(?*TokenList, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: LineCString
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 1;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try arg1.append(arg2);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MultilineCStringLiteral };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.MultilineCStringLiteral;
        },
        else => unreachable,
    }
    return error.ReduceError;
}
