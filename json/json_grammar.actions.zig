// AutoGenerated file

const Types = @import("json_grammar.types.zig");
const Errors = @import("json_grammar.errors.zig");
const Tokens = @import("json_grammar.tokens.zig");

usingnamespace Types;
usingnamespace Errors;
usingnamespace Tokens;

pub const StackItem = struct {
    item: usize,
    state: i16,
    value: StackValue,
};

pub const StackValue = union(enum) {
    Token: Id,
    Terminal: TerminalId,
};

pub fn reduce_actions(comptime Parser: type, parser: *Parser, rule: isize, state: i16) !TerminalId {
    switch (rule) {
        1 => {
            // Symbol: Object
            var result: *Variant = undefined;
            // Symbol: LBrace
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeFields
            const arg2 = @intToPtr(?*Variant.Object, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: RBrace
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = &arg2.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Object };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Object;
        },
        2 => {
            // Symbol: MaybeFields
            var result: *Variant.Object = undefined;

            {
                result = try parser.createVariant(Variant.Object);
                result.fields = VariantMap.init(parser.arena_allocator);
            }
            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeFields } });
            return TerminalId.MaybeFields;
        },
        3 => {
            // Symbol: MaybeFields
            var result: *Variant.Object = undefined;
            // Symbol: Fields
            const arg1 = @intToPtr(?*Variant.Object, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeFields };
            return TerminalId.MaybeFields;
        },
        4 => {
            // Symbol: Fields
            var result: *Variant.Object = undefined;
            // Symbol: StringLiteral
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Colon
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Element
            const arg3 = @intToPtr(?*Variant, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createVariant(Variant.Object);
                result.fields = VariantMap.init(parser.arena_allocator);
                const r = try result.fields.insert(parser.tokenString(arg1));
                if (!r.is_new)
                    return error.JsonDuplicateKeyError;
                r.kv.value = arg3;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Fields };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Fields;
        },
        5 => {
            // Symbol: Fields
            var result: *Variant.Object = undefined;
            // Symbol: Fields
            const arg1 = @intToPtr(?*Variant.Object, parser.stack.items[parser.stack.len - 5].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 4].item).?;
            // Symbol: StringLiteral
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Colon
            const arg4 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Element
            const arg5 = @intToPtr(?*Variant, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 4;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                const r = try result.fields.insert(parser.tokenString(arg3));
                if (!r.is_new)
                    return error.JsonDuplicateKeyError;
                r.kv.value = arg5;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Fields };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Fields;
        },
        6 => {
            // Symbol: Array
            var result: *Variant = undefined;
            // Symbol: LBracket
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: MaybeElements
            const arg2 = @intToPtr(?*VariantList, parser.stack.items[parser.stack.len - 2].item);
            // Symbol: RBracket
            const arg3 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const variant = try parser.createVariant(Variant.Array);
                variant.elements = if (arg2) |l| l.* else VariantList.init(parser.arena_allocator);
                result = &variant.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Array };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Array;
        },
        7 => {
            // Symbol: MaybeElements
            var result: ?*VariantList = null;

            // Push the result of the reduce action
            try parser.stack.append(StackItem{ .item = @ptrToInt(result), .state = state, .value = StackValue{ .Terminal = .MaybeElements } });
            return TerminalId.MaybeElements;
        },
        8 => {
            // Symbol: MaybeElements
            var result: ?*VariantList = null;
            // Symbol: Elements
            const arg1 = @intToPtr(?*VariantList, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .MaybeElements };
            return TerminalId.MaybeElements;
        },
        9 => {
            // Symbol: Elements
            var result: *VariantList = undefined;
            // Symbol: Element
            const arg1 = @intToPtr(?*Variant, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = try parser.createVariantList(VariantList);
                try result.append(arg1);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Elements };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Elements;
        },
        10 => {
            // Symbol: Elements
            var result: *VariantList = undefined;
            // Symbol: Elements
            const arg1 = @intToPtr(?*VariantList, parser.stack.items[parser.stack.len - 3].item).?;
            // Symbol: Comma
            const arg2 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 2].item).?;
            // Symbol: Element
            const arg3 = @intToPtr(?*Variant, parser.stack.items[parser.stack.len - 1].item).?;

            // Adjust the parse stack and current state
            parser.stack.len -= 2;
            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                result = arg1;
                try result.append(arg3);
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Elements };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Elements;
        },
        11 => {
            // Symbol: Element
            var result: *Variant = undefined;
            // Symbol: StringLiteral
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const variant = try parser.createVariant(Variant.StringLiteral);
                variant.value = try parser.unescapeTokenString(arg1);
                result = &variant.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Element };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Element;
        },
        12 => {
            // Symbol: Element
            var result: *Variant = undefined;
            // Symbol: Keyword_null
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const variant = try parser.createVariant(Variant.NullLiteral);
                result = &variant.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Element };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Element;
        },
        13 => {
            // Symbol: Element
            var result: *Variant = undefined;
            // Symbol: Keyword_true
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const variant = try parser.createVariant(Variant.BoolLiteral);
                variant.value = true;
                result = &variant.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Element };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Element;
        },
        14 => {
            // Symbol: Element
            var result: *Variant = undefined;
            // Symbol: Keyword_false
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const variant = try parser.createVariant(Variant.BoolLiteral);
                variant.value = false;
                result = &variant.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Element };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Element;
        },
        15 => {
            // Symbol: Element
            var result: *Variant = undefined;
            // Symbol: IntegerLiteral
            const arg1 = @intToPtr(?*Token, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            {
                const variant = try parser.createVariant(Variant.IntegerLiteral);
                const str = parser.tokenString(arg1);
                var value: isize = 0;
                var signed: bool = str[0] == '-';
                // TODO: integer overflow
                for (str) |c| {
                    if (c == '-') continue;
                    value = value * 10 + (@bitCast(i8, c) - '0');
                }
                variant.value = if (signed) -value else value;
                result = &variant.base;
            }
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Element };
            parser.stack.items[parser.stack.len - 1].item = @ptrToInt(result);
            return TerminalId.Element;
        },
        16 => {
            // Symbol: Element
            var result: *Variant = undefined;
            // Symbol: Object
            const arg1 = @intToPtr(?*Variant, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Element };
            return TerminalId.Element;
        },
        17 => {
            // Symbol: Element
            var result: *Variant = undefined;
            // Symbol: Array
            const arg1 = @intToPtr(?*Variant, parser.stack.items[parser.stack.len - 1].item).?;

            parser.state = parser.stack.items[parser.stack.len - 1].state;
            parser.stack.items[parser.stack.len - 1].state = parser.state;
            parser.stack.items[parser.stack.len - 1].value = StackValue{ .Terminal = .Element };
            return TerminalId.Element;
        },
        else => unreachable,
    }
    return error.ReduceError;
}
